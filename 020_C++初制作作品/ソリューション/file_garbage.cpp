
//-===============================================
//-
//-	ゴミファイル処理[file_garbage.cpp]
//- Author Sakai Minato
//-
//-===============================================

//-======================================
//-	インクルード
//-======================================

#include "file_garbage.h"

#include "manager_object.h"

//-======================================
//-	マクロ定義
//-======================================

//=======================================
//= コンスト定義
//=======================================

// 通常敵のテキストのコンスト定義
const char *pTxtGarbage[] =
{
	"data\\TXT\\Object\\Garbage_000.txt"		// ゴミ_000のテキスト
};

//-======================================
//-	静的変数宣言
//-======================================

CFileGarbage::FileData CFileGarbage::m_aFileData[FILE_DATA_MAX] = {};
int  CFileGarbage::m_nSetMax = 0;

//-------------------------------------
//-	コンストラクタ
//-------------------------------------
CFileGarbage::CFileGarbage()
{
}

//-------------------------------------
//-	デストラクタ
//-------------------------------------
CFileGarbage::~CFileGarbage()
{

}

//-------------------------------------
//- オブジェクトファイルの書き出し処理
//-------------------------------------
void CFileGarbage::Save(CFileGarbage::TXT txtType)
{
	//変数宣言
	FILE *pFile;	// ファイルのポインタ

	// ファイルの情報を代入
	pFile = fopen(pTxtGarbage[txtType], "w");

	// ファイルの有無を判定
	if (pFile != NULL)
	{
		// 変数宣言（敵のモデル数）
		int nMaxNum = 0;

		// 見出しの書き出し
		fprintf(pFile, "#==============================================================================\n");
		fprintf(pFile, "#=\n");
		fprintf(pFile, "#= [敵] \n");
		fprintf(pFile, "#=\n");
		fprintf(pFile, "#==============================================================================\n");
		fprintf(pFile, "\n");

		// モデル数の書き出し
		fprintf(pFile, "#==============================================================================\n");
		fprintf(pFile, "#= [モデル数] \n");
		fprintf(pFile, "#==============================================================================\n");
		fprintf(pFile, "%d\n", nMaxNum);
		fprintf(pFile, "\n");

		// 配置状況見出しの書き出し
		fprintf(pFile, "#==============================================================================\n");
		fprintf(pFile, "#= [配置情報] \n");
		fprintf(pFile, "#==============================================================================\n");
		fprintf(pFile, "\n");

		for (int nCount = 0; nCount < OBJECTX_NONE_NUM_MAX; nCount++)
		{
			// 変数宣言（指定の敵のポインタ取得）
			CGarbage *pGarbage = CManagerObject::GetGarbage(nCount);

			// 敵の有無を判定
			if (pGarbage != NULL)
			{
				// 変数宣言（敵の情報取得）
				int nModelNldx = pGarbage->GetModel();			// 使用モデル番号
				D3DXVECTOR3 pos = pGarbage->m_dataPos.Get();	// 位置
				D3DXVECTOR3 rot = pGarbage->m_dataRot.Get();	// 向き

				// 配置モデルの情報の書き出し
				fprintf(pFile, "MODEL = %d\n", nModelNldx);
				fprintf(pFile, " --- POS = %3.1f %3.1f %3.1f \n", pos.x, pos.y, pos.z);
				fprintf(pFile, " --- ROT = %3.1f %3.1f %3.1f \n", rot.x, rot.y, rot.z);
				fprintf(pFile, "END_MODEL_SET \n");
				fprintf(pFile, "\n");
			}
		}

		// 書き出しの終了
		fprintf(pFile, "SET_END");

		// ファイルを閉じる
		fclose(pFile);
	}
}

//-------------------------------------
//- オブジェクトファイルの読み込み処理
//-------------------------------------
void CFileGarbage::Load(CFileGarbage::TXT txtType)
{
	//変数宣言
	FILE *pFile;	// ファイルのポインタ

	// ファイルの情報を代入
	pFile = fopen(pTxtGarbage[txtType], "r");

	int nObjCount = 0;

	// ファイルの有無を判定
	if (pFile != NULL)
	{
		// 変数宣言
		char aFileData[256] = { 0 };	// ファイルの文章を格納

		while (true)
		{
			// 文字列を読み込み
			fgets(aFileData, 256, pFile);

			// 文字数分読み込み
			for (int nCount = 0; nCount < 256; nCount++)
			{
				// コメントを判定
				if (aFileData[nCount] == '#')
				{
					// コメントを除去
					memset(&aFileData[nCount], NULL, sizeof(256 - nCount));
					break;
				}
			}

			if (strstr(aFileData, "MODEL") != NULL)
			{
				if (strstr(aFileData, "=") != NULL)
				{
					// 変数宣言
					char aTenp[2][256] = {};	// ゴミ入れ	
					int nValue = 0;				// 数値

					// 数値を取り出す
					sscanf(aFileData, "%s %s %d", aTenp[0], aTenp[1], &nValue);

					// モデル番号を保存
					m_aFileData[nObjCount].modelNldx = nValue;
				}
			}

			if (strstr(aFileData, "POS") != NULL)
			{
				// 特定の文字を判定
				if (strstr(aFileData, "=") != NULL)
				{
					// 変数宣言
					char aTenp[3][256] = {};	// ゴミ入れ	
					float fPosX = 0;			// 位置（X）
					float fPosY = 0;			// 位置（Y）
					float fPosZ = 0;			// 位置（Z）

					// 数値を取り出す
					sscanf(aFileData, "%s %s %s %f %f %f", aTenp[0], aTenp[1], aTenp[2], &fPosX, &fPosY, &fPosZ);

					// 位置情報を保存
					m_aFileData[nObjCount].pos = D3DXVECTOR3(fPosX,fPosY,fPosZ);
				}
			}

			// 向き情報の判定
			if (strstr(aFileData, "ROT") != NULL)
			{
				// 特定の文字を判定
				if (strstr(aFileData, "=") != NULL)
				{
					// 変数宣言
					char aTenp[3][256] = {};	// ゴミ入れ	
					float fRotX = 0;			// 向き（X）
					float fRotY = 0;			// 向き（Y）
					float fRotZ = 0;			// 向き（Z）

					// 数値を取り出す
					sscanf(aFileData, "%s %s %s %f %f %f", aTenp[0], aTenp[1], aTenp[2], &fRotX, &fRotY, &fRotZ);

					// 位置情報を保存
					m_aFileData[nObjCount].rot = D3DXVECTOR3(fRotX, fRotY, fRotZ);
				}
			}

			// モデル設定の終了
			if (strstr(aFileData, "END_MODEL_SET") != NULL)
			{
				nObjCount++;
			}

			// モデル設定の終了 （ 終わりの文を見つけた || 格納場所がない ） 
			if (strstr(aFileData, "SET_END") != NULL)
			{
				m_nSetMax = nObjCount;

				break;
			}
		}

		// ファイルを閉じる
		fclose(pFile);
	}
}

//-------------------------------------
//- オブジェクトファイルの置く処理
//-------------------------------------
void CFileGarbage::Locate(void)
{
	for (int nCount = 0; nCount < m_nSetMax; nCount++)
	{
		// ゴミの有無を判定
		if (m_aFileData[nCount].bNoLoad == false)
		{
			// ゴミの生成処理
			CGarbage *pGarbage = CGarbage::Create((CGarbage::MODEL)m_aFileData[nCount].modelNldx);

			// 設定処理
			pGarbage->Set(
				m_aFileData[nCount].pos,
				m_aFileData[nCount].rot);

			// 通常敵のポインタを代入
			CManagerObject::SetGarbage(nCount, pGarbage);
		}
	}
}

//-------------------------------------
//- オブジェクトファイルの確認処理
//-------------------------------------
void CFileGarbage::ObjCheck(void)
{
	for (int nCount = 0; nCount < m_nSetMax; nCount++)
	{
		// ゴミの有無を判定
		if (CManagerObject::GetGarbage(nCount) == NULL)
		{
			m_aFileData[nCount].bNoLoad = true;
		}
	}
}

//-------------------------------------
//- オブジェクトファイルの復活処理
//-------------------------------------
void CFileGarbage::ObjRecall(void)
{
	for (int nCount = 0; nCount < m_nSetMax; nCount++)
	{
		m_aFileData[nCount].bNoLoad = false;
	}
}